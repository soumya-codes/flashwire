// Code generated by Flashwire Codegen. DO NOT EDIT.

package main

import (
	"bytes"
	"github.com/soumya-codes/flashwire/internal/bufferpool"
)
import "slices"

import "github.com/soumya-codes/flashwire/internal/varint"
import "github.com/soumya-codes/flashwire/internal/int32/codec"

// MarshalBinary encodes DataInput into a new byte slice.
func (d *DataInput) MarshalBinary() ([]byte, error) {
	buf, err := d.MarshalBinaryBorrowed()
	if err != nil {
		return nil, err
	}
	defer bufferpool.PutBuffer(buf)
	return slices.Clone(buf.Bytes()), nil
}

// MarshalBinaryBorrowed encodes DataInput and returns a borrowed buffer.
// Caller MUST call codec.PutBuffer(buf) after use.
func (d *DataInput) MarshalBinaryBorrowed() (*bytes.Buffer, error) {
	w := bufferpool.GetBuffer()
	enc := codec.NewWriterFromBuffer(w)
	if err := enc.WriteInt32(d.Foo); err != nil {
		bufferpool.PutBuffer(w)
		return nil, err
	}
	if err := enc.WriteInt32(d.Bar); err != nil {
		bufferpool.PutBuffer(w)
		return nil, err
	}

	return w, nil
}
// UnmarshalBinary decodes bytes into DataInput.
func (d *DataInput) UnmarshalBinary(data []byte) error {
	r := codec.NewReader(data)
	vFoo, err := r.ReadInt32()
	if err != nil {
		return err
	}
	d.Foo = vFoo
	vBar, err := r.ReadInt32()
	if err != nil {
		return err
	}
	d.Bar = vBar
	return nil
}
// Size returns the size of the encoded DataInput.
func (d *DataInput) Size() int {
	size := 0
	size += varint.VarintSize(uint64(codec.ZigzagEncode32(d.Foo)))
	size += varint.VarintSize(uint64(codec.ZigzagEncode32(d.Bar)))
	return size
}
