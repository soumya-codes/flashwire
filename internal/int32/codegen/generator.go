package codegen

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"text/template"
)

// Field represents a field inside a struct (e.g., an int32 field).
type Field struct {
	Name string
	Type string
}

// TemplateContext is passed to templates for code generation.
type TemplateContext struct {
	TypeName string
	Fields   []Field
}

// Generator is responsible for generating encoder/decoder code for a type.
type Generator struct {
	typeName  string
	outputDir string
	outputPkg string
	templates *template.Template
}

// NewGenerator creates a new Generator.
func NewGenerator(typeName, outputDir, outputPkg, templatesDir string) (*Generator, error) {
	if templatesDir == "" {
		return nil, fmt.Errorf("templates directory must be provided")
	}
	tmpls, err := loadTemplates(templatesDir)
	if err != nil {
		return nil, err
	}

	return &Generator{
		typeName:  typeName,
		outputDir: outputDir,
		outputPkg: outputPkg,
		templates: tmpls,
	}, nil
}

// Generate reads the Go struct and generates encode/decode/size methods.
func (g *Generator) Generate(inputFile string) error {
	fset := token.NewFileSet()
	node, err := parser.ParseFile(fset, inputFile, nil, parser.AllErrors)
	if err != nil {
		return err
	}

	var fields []Field

	// Find struct
	for _, decl := range node.Decls {
		genDecl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		for _, spec := range genDecl.Specs {
			typeSpec, ok := spec.(*ast.TypeSpec)
			if !ok || typeSpec.Name.Name != g.typeName {
				continue
			}
			structType, ok := typeSpec.Type.(*ast.StructType)
			if !ok {
				continue
			}
			// Extract fields
			for _, field := range structType.Fields.List {
				for _, name := range field.Names {
					// Only pick int32 fields for now
					if ident, ok := field.Type.(*ast.Ident); ok && ident.Name == "int32" {
						fields = append(fields, Field{
							Name: name.Name,
							Type: "int32",
						})
					}
				}
			}
		}
	}

	if len(fields) == 0 {
		return fmt.Errorf("no int32 fields found in struct %s", g.typeName)
	}

	// Prepare context
	ctx := TemplateContext{
		TypeName: g.typeName,
		Fields:   fields,
	}

	// Create output dir if not exists
	err = os.MkdirAll(g.outputDir, 0755)
	if err != nil {
		return err
	}

	// Output generated file
	outFile := filepath.Join(g.outputDir, g.typeName+"_gen.go")
	f, err := os.Create(outFile)
	if err != nil {
		return err
	}
	defer f.Close()

	// Write header
	fmt.Fprintf(f, "// Code generated by Flashwire Codegen. DO NOT EDIT.\n\n")
	fmt.Fprintf(f, "package %s\n\n", g.outputPkg)

	fmt.Fprintf(f, "import \"bytes\"\n")
	fmt.Fprintf(f, "import \"slices\"\n\n")
	fmt.Fprintf(f, "import \"github.com/soumya-codes/flashwire/internal/varint\"\n")
	fmt.Fprintf(f, "import \"github.com/soumya-codes/flashwire/internal/int32/codec\"\n\n")

	// Execute templates
	if err := g.templates.ExecuteTemplate(f, "encode.tmpl", ctx); err != nil {
		return err
	}
	if err := g.templates.ExecuteTemplate(f, "decode.tmpl", ctx); err != nil {
		return err
	}
	if err := g.templates.ExecuteTemplate(f, "size.tmpl", ctx); err != nil {
		return err
	}

	return nil
}

// loadTemplates loads all templates from templates/ directory.
func loadTemplates(templatesDir string) (*template.Template, error) {
	tmpl := template.New("codegen")
	paths := []string{
		filepath.Join(templatesDir, "encode.tmpl"),
		filepath.Join(templatesDir, "decode.tmpl"),
		filepath.Join(templatesDir, "size.tmpl"),
	}
	for _, p := range paths {
		content, err := os.ReadFile(filepath.Clean(p))
		if err != nil {
			return nil, err
		}
		child := tmpl.New(filepath.Base(p))
		_, err = child.Parse(string(content))
		if err != nil {
			return nil, err
		}
	}
	return tmpl, nil
}
